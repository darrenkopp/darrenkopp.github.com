---
layout: post
title: Embrace value types
date: 2013-05-31 18:36:00-0600
published: false
categories:
- coding
tags:
- struct
- value-types
---

<p>
    The other day I saw some code that made me do a double-take. 
</p>

{% highlight csharp %}
double meters = 25.0;
double feet = ConversionUtility.ToFeet(meters);

Console.WriteLine(feet);
{% endhighlight %}

<p>
    The code works correctly, but it's not ideal. How do we know that we don't already have our value in feet?
    While that's question may be answered by the data source, I believe we can improve by leveraging operator overloading and 
    <a href="http://en.wikipedia.org/wiki/Value_object">introducing our own types to represent these values</a>.
    Once we have our own types, we can easily embed the conversion logic between different units into the struct.
    To me, what we would ideally like is the following:
</p>
<h3>Refactoring</h3>

{% highlight csharp %}
Meter meters = 25.0;
Foot feet = (Foot)meters;

Console.WriteLine(feet);
{% endhighlight %}

<p>
    That's a lot cleaner. The code will effectively work the same as before. The only complication is that you now need provide implementations for operators like <code>+</code>, <code>-</code>, 
    <code>*</code>, <code>/</code>, and so forth, that you are used to being provided by the framework if you need them.
</p>
<p>
    Additionally, we are now able to extend our type and add useful conversion methods.
    If I want to know how many miles I have from a foot instance, I could add a property on there that does that conversion for me.
    Perhaps if the concept of a mile is important enough to me, I could add a Mile type and add an implicit conversion between Foot and Mile.
    Right now the only way to do this is through extension methods which is less than ideal.
</p>
<p>
    There's a lot of examples of this in the .NET framework already like <code>TimeSpan</code>, <code>Guid</code>, 
    and even the <code>string</code> data type. Technically every primitive type we have is just wrapping one or my byte values in
    a meaningful way that helps us write simpler, cleaner code.
</p>
<p>
    Once we have wrapped our raw values into a type, we have given that value an identity and rules that we must abide by.
    Naturally, we can then start forming much more expressive code that has stricter behavior that we are limited to with <code>double</code>.
    While this example is fairly simple, this type of refactoring has many applications, even beyond what you might consider a 
    straightforward conversion.
</p>
<h3>Conclusion</h3>
<p>
    In the future, take a moment and consider when you are using a built-in type such as <code>Guid</code> or <code>double</code> 
    and think if you could gain any benefit from wrapping the value. In many cases you may find that you can in fact gain a lot 
    of benefits from doing so. Below is the simplistic code for the structs from the sample code earlier. It only contains the implicit casts 
    between double, Feet, and Meter values, but you can easily extend them to add support for many other operators and casts.
</p>

{% highlight csharp %}
struct Meter
{
    readonly double Length;
    public Meter(double length)
    {
        Length = length;
    }

    public static implicit operator Foot(Meter meter)
    {
        return new Foot(meter.Length * 3.28084);
    }

    public static implicit operator double(Meter meter)
    {
        return meter.Length;
    }

    public override string ToString()
    {
        return Length.ToString();
    }
}

struct Foot
{
    readonly double Length;
    public Foot(double length)
    {
        Length = length;
    }

    public static implicit operator Meter(Foot foot)
    {
        return new Meter(foot.Length * 0.3048);
    }

    public static implicit operator double(Foot foot)
    {
        return foot.Length;
    }

    public override string ToString()
    {
        return Length.ToString();
    }
}
{% endhighlight %}